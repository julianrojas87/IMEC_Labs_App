var util = require('util')
  , Transform = require('stream').Transform

/**
 * The Connection Scan Algorithm (CSA) scans each connection and checks whether we can take this connection to get a path
 */
var ResultStream = function (query, parentStop) {
  Transform.call(this, {objectMode: true});
  //parentStop function is optional
  this._parentStop = parentStop || function (stop) { return stop; };
  //Contains for each stop an object of: arrival time and connection id
  this._earliestArrivalTimes = {};
  //check the fields of query and assign them to the object. Validate them against possible errors
  if (query) {
    this._latestArrivalTime = query.latestArrivalTime;
    this._departureStop = this._parentStop(query.departureStop);
    this._arrivalStop = this._parentStop(query.arrivalStop);
    if (this._departureStop === this._arrivalStop) {
      throw "You are already at this location";
    }
    this._departureTime = query.departureTime;
    this._earliestArrivalTimes[this._departureStop] = query.departureTime;
  } else {
    throw "no query found";
  }
  //List of encountered connections that we'll need further on
  this._connections = {};

  //Counts the number of relaxed connections
  this._count = 0;
};

util.inherits(ResultStream, Transform);

/**
 * Users of this library should make sure the connections piped to this stream are ordered in time
 */
ResultStream.prototype._transform = function (connection, encoding, done) {
  this._count++;
  var departureStop = this._parentStop(connection["departureStop"]);
  var arrivalStop = this._parentStop(connection["arrivalStop"]);
  //If the connection we encounter departs at a stop that is reachable, then it's a connection worth further examining
  if (this._earliestArrivalTimes[departureStop]) {
    //Store all the reachable connections by id for future use. This way, we can reference each connection by id in all other objects
    this._connections[connection["@id"]] = connection;
    
    //Add a next connection to the departure stop where we see an appropriate transfer.
    //This is the difficult part, as we have to know more about the specifics of getting from 1 connection to another.
    //It may be the same vehicle, for which we will not require a transfer time
    //It may also be a connection at a different time and/or stop, for which we will calculate a footpath
    this._earliestArrivalTimes[departureStop];

    //Check whether we have a new stop
    if (!this._earliestArrivalTimes[arrivalStop]) {
      this._earliestArrivalTimes[arrivalStop] = connection["arrivalTime"];
      //Emit an event with the connection which denotes the earliest arrival time at this arrivalStop (handy for creating isochrones)
      this.emit("earliestArrivalTime",connection);
    }
    
    this._connections[connection["@id"]]
      .push({
      "@id" : connection["@id"],
      "arrivalTime" : connection["arrivalTime"]
    });
    
    //Check whether we've found a result and return it, otherwise, continue
    if (this._arrivalStop && arrivalStop === this._arrivalStop) {
      done(null, this._reconstructRoute());
    } else {
      done();
    }
  }
  //The departure stop is not reachable: skip this one
  else {
    done();
  }
};

/**
 *
 * @return First Connection at a stop after a certain dateTime
 */
ResultStream.prototype._getConnectionAtStop = function (stop, earliestDepartureTime) {
  
};

/**
 * 
 * @return Returns the index at which it was inserted
 */
ResultStream.prototype._insertConnectionAtStop = function (stop, connection) {

};

ResultStream.prototype._reconstructRoute = function () {
  var path = [];
  var previous = this._minimumSpanningTree[this._arrivalStop].connection1;
  while (previous) {
    path.unshift(previous);
    if (this._minimumSpanningTree[this._parentStop(previous["departureStop"])]) {
      previous = this._minimumSpanningTree[this._parentStop(previous["departureStop"])].connection1;
    } else {
      previous = null;
    }
  }
  return path;
};

module.exports = ResultStream;
